<?php

use Drupal\comment\Entity\CommentType;
use Drupal\Core\Entity\EntityStorageException;
use Drupal\node\Entity\NodeType;
use Drupal\field\Entity\FieldStorageConfig;
use Drupal\field\Entity\FieldConfig;
use Drupal\Core\Entity\Entity\EntityFormDisplay;
use Drupal\Core\Entity\Entity\EntityViewDisplay;
use Drupal\mantle2\Controller\Schema\Mantle2Schemas;
use Drupal\mantle2\Custom\AccountType;
use Drupal\mantle2\Custom\EventType;
use Drupal\mantle2\Custom\Visibility;
use Drupal\mantle2\Service\UsersHelper;
use Drupal\node\NodeInterface;

function createField(
	string $entity,
	string $name,
	string $type,
	string $label,
	bool $required = false,
	$default_value = null,
	array $settings = [],
	array $constraints = [],
	int $cardinality = 1,
	?string $bundle = null,
): void {
	// If no bundle is provided, default to entity (e.g., user entity uses 'user' bundle).
	$bundle = $bundle ?? $entity;
	$field_is_new = false;

	if (!FieldStorageConfig::loadByName($entity, $name)) {
		try {
			FieldStorageConfig::create([
				'field_name' => $name,
				'entity_type' => $entity,
				'type' => $type,
				'cardinality' => $cardinality,
				'settings' => $settings,
			])->save();
			$field_is_new = true;
		} catch (EntityStorageException $e) {
			Drupal::logger('mantle2')->error(
				'Failed to save field constraints for %field: %message',
				[
					'%field' => $name,
					'%message' => $e->getMessage(),
				],
			);
		}
	}

	if (!FieldConfig::loadByName($entity, $bundle, $name)) {
		try {
			FieldConfig::create([
				'field_name' => $name,
				'entity_type' => $entity,
				'bundle' => $bundle,
				'label' => $label,
				'required' => $required,
			])->save();
			$field_is_new = true;
		} catch (EntityStorageException $e) {
			Drupal::logger('mantle2')->error(
				'Failed to save field constraints for %field: %message',
				[
					'%field' => $name,
					'%message' => $e->getMessage(),
				],
			);
		}
	}

	// Ensure instance-level settings like default values and constraints are saved.
	$field = FieldConfig::load("$entity.$bundle.$name");
	if ($field) {
		if ($default_value !== null) {
			$prepared_default = is_array($default_value)
				? $default_value
				: [['value' => $default_value]];
			$field->set('default_value', $prepared_default);
		}
		if ($constraints) {
			$field->setSetting('constraints', $constraints);
		}
		try {
			$field->save();
		} catch (EntityStorageException $e) {
			Drupal::logger('mantle2')->error(
				'Failed to save field configuration for %field: %message',
				[
					'%field' => $name,
					'%message' => $e->getMessage(),
				],
			);
		}
	}

	// if new field and has default value, populate existing entities with default
	if ($field_is_new && $default_value !== null) {
		populateExistingEntitiesWithFieldDefault($entity, $bundle, $name, $default_value);
	}
}

/**
 * Populate existing entities with default values for a newly created field.
 */
function populateExistingEntitiesWithFieldDefault(
	string $entity_type,
	string $bundle,
	string $field_name,
	$default_value,
): void {
	try {
		$entity_storage = Drupal::entityTypeManager()->getStorage($entity_type);

		// Build query based on entity type
		$query = $entity_storage->getQuery()->accessCheck(false);

		// For node entities, filter by bundle (content type)
		if ($entity_type === 'node') {
			$query->condition('type', $bundle);
		} elseif ($entity_type === 'comment') {
			$query->condition('comment_type', $bundle);
		}

		$entity_ids = $query->execute();

		if (empty($entity_ids)) {
			return;
		}

		// Load entities in batches to avoid memory issues
		$batch_size = 50;
		$batches = array_chunk($entity_ids, $batch_size);

		foreach ($batches as $batch_ids) {
			$entities = $entity_storage->loadMultiple($batch_ids);

			foreach ($entities as $entity) {
				/** @var \Drupal\Core\Entity\FieldableEntityInterface $entity */
				if ($entity->hasField($field_name) && $entity->get($field_name)->isEmpty()) {
					$entity->set($field_name, $default_value);
					try {
						$entity->save();
					} catch (Exception $e) {
						Drupal::logger('mantle2')->warning(
							'Failed to populate field %field on %entity_type %id: %message',
							[
								'%field' => $field_name,
								'%entity_type' => $entity_type,
								'%id' => $entity->id(),
								'%message' => $e->getMessage(),
							],
						);
					}
				}
			}
		}

		Drupal::logger('mantle2')->info(
			'Populated %count existing %entity_type entities with default value for field %field',
			[
				'%count' => count($entity_ids),
				'%entity_type' => $entity_type,
				'%field' => $field_name,
			],
		);
	} catch (Exception $e) {
		Drupal::logger('mantle2')->error(
			'Failed to populate existing entities with field %field: %message',
			[
				'%field' => $field_name,
				'%message' => $e->getMessage(),
			],
		);
	}
}

/**
 * Ensure all fields are visible in the default form display for a bundle.
 */
function mantle2_ensure_form_display(string $entity_type, string $bundle): void
{
	/** @var Drupal\Core\Entity\Entity\EntityFormDisplay $display */
	$display = EntityFormDisplay::load("$entity_type.$bundle.default");
	if (!$display) {
		$display = EntityFormDisplay::create([
			'targetEntityType' => $entity_type,
			'bundle' => $bundle,
			'mode' => 'default',
			'status' => true,
		]);
	}
	$display->setStatus(true);

	// Load all field instances for this bundle.
	$field_instances = Drupal::entityTypeManager()
		->getStorage('field_config')
		->loadByProperties(['entity_type' => $entity_type, 'bundle' => $bundle]);

	$weight = 0;
	foreach ($field_instances as $field_config) {
		/** @var Drupal\field\Entity\FieldConfig $field_config */
		$name = $field_config->getName();
		$type = $field_config->getType();

		$component = $display->getComponent($name) ?? [];
		$widget = getWidgetType($type);
		if ($type === 'json') {
			$widget = 'json_textarea';
		}

		$display->setComponent(
			$name,
			$component + [
				'type' => $widget,
				'weight' => $weight++,
				'settings' => $component['settings'] ?? [],
				'region' => 'content',
			],
		);
	}

	try {
		$display->save();
	} catch (EntityStorageException $e) {
		Drupal::logger('mantle2')->error('Failed to save form display for %bundle: %message', [
			'%bundle' => "$entity_type.$bundle",
			'%message' => $e->getMessage(),
		]);
	}
}

function createContentType(string $name, string $label, string $description, array $fields): void
{
	// Ensure the content type (bundle) exists.
	$existing = NodeType::load($name);
	if (!$existing) {
		$type = NodeType::create([
			'type' => $name,
			'name' => $label,
			'description' => $description,
		]);
		try {
			$type->save();
		} catch (EntityStorageException $e) {
			Drupal::logger('mantle2')->error('Failed to save content type %type: %message', [
				'%type' => $name,
				'%message' => $e->getMessage(),
			]);
		}
	}

	// Add fields to the 'node' entity for this bundle.
	foreach ($fields as $field) {
		createField(
			'node', // Correct entity type for nodes
			$field['name'],
			$field['type'],
			$field['label'],
			$field['required'] ?? false,
			$field['default_value'] ?? null,
			$field['settings'] ?? [],
			$field['constraints'] ?? [],
			$field['cardinality'] ?? 1,
			$name, // bundle: machine name of the content type
		);
	}

	// Configure form display to make fields visible on add/edit forms
	$form_display = EntityFormDisplay::load("node.$name.default");
	if (!$form_display) {
		$form_display = EntityFormDisplay::create([
			'targetEntityType' => 'node',
			'bundle' => $name,
			'mode' => 'default',
			'status' => true,
		]);
	}
	$form_display->setStatus(true);

	// Set up form display for each field
	foreach ($fields as $index => $field) {
		$field_name = $field['name'];
		$field_type = $field['type'];

		// Configure widget based on field type
		$widget_config = [
			'type' => getWidgetType($field_type),
			'weight' => $index,
			'settings' => [],
			'region' => 'content',
		];

		// Add specific widget settings based on field type
		if ($field_type === 'datetime') {
			$widget_config['settings']['datetime_type'] = 'datetime';
		} elseif ($field_type === 'list_string') {
			$widget_config['type'] = 'options_select';
		} elseif ($field_type === 'json') {
			$widget_config['type'] = 'json_textarea';
		}

		$form_display->setComponent($field_name, $widget_config);
	}

	try {
		$form_display->save();
	} catch (EntityStorageException $e) {
		Drupal::logger('mantle2')->error('Failed to save form display for %type: %message', [
			'%type' => $name,
			'%message' => $e->getMessage(),
		]);
	}

	// Ensure any fields not explicitly configured above are still made visible.
	mantle2_ensure_form_display('node', $name);
}

function getWidgetType(string $field_type): string
{
	$widget_map = [
		'string' => 'string_textfield',
		'integer' => 'number',
		'float' => 'number',
		'text' => 'text_textarea',
		'text_long' => 'text_textarea',
		'datetime' => 'datetime_default',
		'list_string' => 'options_select',
		'json' => 'json_textarea',
		'entity_reference' => 'entity_reference_autocomplete',
		'comment' => 'comment_default',
	];

	return $widget_map[$field_type] ?? 'string_textfield';
}

/**
 * Backup event activity data before migration.
 * Returns backup ID for restoration if needed.
 */
function mantle2_backup_event_activities(): ?string
{
	try {
		$event_storage = Drupal::entityTypeManager()->getStorage('node');
		$event_query = $event_storage->getQuery()->condition('type', 'event')->accessCheck(false);
		$event_ids = $event_query->execute();

		if (empty($event_ids)) {
			return null;
		}

		$backup_data = [];
		$events = $event_storage->loadMultiple($event_ids);

		foreach ($events as $event) {
			/** @var \Drupal\node\NodeInterface $event */
			$nid = $event->id();
			$field_data = $event->get('field_event_activity_types')->getValue();

			if (!empty($field_data)) {
				$backup_data[$nid] = $field_data;
			}
		}

		if (empty($backup_data)) {
			return null;
		}

		// Generate unique backup ID
		$backup_id = 'event_activities_backup_' . time() . '_' . bin2hex(random_bytes(8));

		// Try Redis first
		if (class_exists('\Drupal\mantle2\Service\RedisHelper')) {
			$success = \Drupal\mantle2\Service\RedisHelper::set($backup_id, $backup_data, 3600);
			if ($success) {
				Drupal::logger('mantle2')->info('Event activities backed up to Redis: %id', [
					'%id' => $backup_id,
				]);
				return $backup_id;
			}
		}

		// Fallback to database table
		$connection = Drupal::database();

		// Create backup table if it doesn't exist
		$schema = $connection->schema();
		if (!$schema->tableExists('mantle2_migration_backup')) {
			$table_schema = [
				'fields' => [
					'backup_id' => ['type' => 'varchar', 'length' => 255, 'not null' => true],
					'backup_data' => ['type' => 'text', 'size' => 'big', 'not null' => true],
					'created' => ['type' => 'int', 'not null' => true],
				],
				'primary key' => ['backup_id'],
			];
			$schema->createTable('mantle2_migration_backup', $table_schema);
		}

		// Store backup in database
		$connection
			->insert('mantle2_migration_backup')
			->fields([
				'backup_id' => $backup_id,
				'backup_data' => json_encode($backup_data),
				'created' => time(),
			])
			->execute();

		Drupal::logger('mantle2')->info('Event activities backed up to database: %id', [
			'%id' => $backup_id,
		]);

		return $backup_id;
	} catch (Exception $e) {
		Drupal::logger('mantle2')->error('Failed to backup event activities: %message', [
			'%message' => $e->getMessage(),
		]);
		return null;
	}
}

/**
 * Migrate event activity data from list_string to JSON format.
 * Returns migrated data or null on failure.
 */
function mantle2_migrate_event_activities(): ?array
{
	try {
		$existing_storage = FieldStorageConfig::loadByName('node', 'field_event_activity_types');

		if (!$existing_storage || $existing_storage->getType() !== 'list_string') {
			// No migration needed
			return [];
		}

		$event_storage = Drupal::entityTypeManager()->getStorage('node');
		$event_query = $event_storage->getQuery()->condition('type', 'event')->accessCheck(false);
		$event_ids = $event_query->execute();

		$migrated_data = [];

		if (!empty($event_ids)) {
			$events = $event_storage->loadMultiple($event_ids);

			foreach ($events as $event) {
				/** @var \Drupal\node\NodeInterface $event */
				$nid = $event->id();
				$old_values = $event->get('field_event_activity_types')->getValue();

				// Convert old ordinal values to new JSON format
				$new_activities = [];
				foreach ($old_values as $item) {
					$ordinal = $item['value'] ?? null;
					if ($ordinal !== null) {
						$activity_type =
							Drupal\mantle2\Custom\ActivityType::cases()[$ordinal] ?? null;
						if ($activity_type) {
							$new_activities[] = [
								'type' => 'activity_type',
								'value' => $activity_type->value,
							];
						}
					}
				}

				if (!empty($new_activities)) {
					$migrated_data[$nid] = json_encode($new_activities);
				}
			}
		}

		// Delete old field configuration
		$field_config = FieldConfig::loadByName('node', 'event', 'field_event_activity_types');
		if ($field_config) {
			$field_config->delete();
		}

		// Delete old field storage - purge any remaining data first
		try {
			// Mark storage for deletion
			$existing_storage->delete();
			Drupal::service('field.field_config_storage')->purgeFieldData();
		} catch (Exception $e) {
			// If deletion fails due to missing tables, forcefully remove the storage config
			Drupal::logger('mantle2')->warning(
				'Standard field deletion failed, attempting direct removal: %message',
				['%message' => $e->getMessage()],
			);

			// Delete field storage config directly from database
			try {
				$connection = Drupal::database();

				// Remove field storage config
				$connection
					->delete('config')
					->condition('name', 'field.storage.node.field_event_activity_types')
					->execute();

				// Drop field tables if they exist
				$schema = $connection->schema();
				$tables = [
					'node__field_event_activity_types',
					'node_revision__field_event_activity_types',
				];

				foreach ($tables as $table) {
					if ($schema->tableExists($table)) {
						$schema->dropTable($table);
					}
				}

				// Clear field info cache
				Drupal::service('entity_field.manager')->clearCachedFieldDefinitions();
			} catch (Exception $inner_e) {
				Drupal::logger('mantle2')->error('Failed to forcefully remove field: %message', [
					'%message' => $inner_e->getMessage(),
				]);
				throw $inner_e;
			}
		}

		Drupal::logger('mantle2')->info(
			'Migrated %count event activities from list_string to JSON',
			[
				'%count' => count($migrated_data),
			],
		);

		return $migrated_data;
	} catch (Exception $e) {
		Drupal::logger('mantle2')->error('Failed to migrate event activities: %message', [
			'%message' => $e->getMessage(),
		]);
		return null;
	}
}

/**
 * Restore migrated activity data to events.
 * Returns true on success, false on failure.
 */
function mantle2_restore_event_activities(array $migrated_data): bool
{
	if (empty($migrated_data)) {
		return true;
	}

	try {
		$event_storage = Drupal::entityTypeManager()->getStorage('node');
		$success_count = 0;
		$error_count = 0;

		foreach ($migrated_data as $nid => $json_data) {
			try {
				/** @var \Drupal\node\NodeInterface $event */
				$event = $event_storage->load($nid);
				if ($event) {
					$event->set('field_event_activity_types', $json_data);
					$event->save();
					$success_count++;
				}
			} catch (Exception $e) {
				$error_count++;
				Drupal::logger('mantle2')->warning(
					'Failed to restore activity data for event %nid: %message',
					[
						'%nid' => $nid,
						'%message' => $e->getMessage(),
					],
				);
			}
		}

		if ($error_count > 0) {
			Drupal::logger('mantle2')->warning('Restored %success events, %errors failed', [
				'%success' => $success_count,
				'%errors' => $error_count,
			]);
		} else {
			Drupal::logger('mantle2')->info(
				'Successfully restored activity data for %count events',
				[
					'%count' => $success_count,
				],
			);
		}

		return $error_count === 0;
	} catch (Exception $e) {
		Drupal::logger('mantle2')->error('Failed to restore event activities: %message', [
			'%message' => $e->getMessage(),
		]);
		return false;
	}
}

/**
 * Rollback migration using backup data.
 */
function mantle2_rollback_event_activities(string $backup_id): bool
{
	try {
		$backup_data = null;

		// Try Redis first
		if (class_exists('\Drupal\mantle2\Service\RedisHelper')) {
			$backup_data = \Drupal\mantle2\Service\RedisHelper::get($backup_id);
		}

		// Fallback to database
		if ($backup_data === null) {
			$connection = Drupal::database();
			$result = $connection
				->select('mantle2_migration_backup', 'b')
				->fields('b', ['backup_data'])
				->condition('backup_id', $backup_id)
				->execute()
				->fetchField();

			if ($result) {
				$backup_data = json_decode($result, true);
			}
		}

		if ($backup_data === null) {
			Drupal::logger('mantle2')->error('Backup data not found: %id', ['%id' => $backup_id]);
			return false;
		}

		// Restore backup data
		$event_storage = Drupal::entityTypeManager()->getStorage('node');
		foreach ($backup_data as $nid => $field_data) {
			try {
				/** @var \Drupal\node\NodeInterface $event */
				$event = $event_storage->load($nid);
				if ($event) {
					$event->set('field_event_activity_types', $field_data);
					$event->save();
				}
			} catch (Exception $e) {
				Drupal::logger('mantle2')->warning('Failed to rollback event %nid: %message', [
					'%nid' => $nid,
					'%message' => $e->getMessage(),
				]);
			}
		}

		// Clean up backup
		if (class_exists('\Drupal\mantle2\Service\RedisHelper')) {
			\Drupal\mantle2\Service\RedisHelper::delete($backup_id);
		}

		$connection = Drupal::database();
		if ($connection->schema()->tableExists('mantle2_migration_backup')) {
			$connection
				->delete('mantle2_migration_backup')
				->condition('backup_id', $backup_id)
				->execute();
		}

		Drupal::logger('mantle2')->info('Rollback completed for backup: %id', [
			'%id' => $backup_id,
		]);
		return true;
	} catch (Exception $e) {
		Drupal::logger('mantle2')->error('Failed to rollback: %message', [
			'%message' => $e->getMessage(),
		]);
		return false;
	}
}

/** @noinspection PhpUnused */
function mantle2_install(): void
{
	// User Fields

	/// Visibility
	createField('user', 'field_visibility', 'list_string', 'Visibility', true, null, [
		'allowed_values' => array_map(fn($case) => $case->value, Visibility::cases()),
	]);

	/// Field Privacy
	createField(
		'user',
		'field_privacy',
		'json',
		'Field Privacy',
		true,
		json_encode(UsersHelper::$defaultPrivacy),
		[
			'schema' => Mantle2Schemas::userFieldPrivacyJson(),
		],
	);

	/// First Name
	createField('user', 'field_first_name', 'string', 'First Name', false, '', [
		'max_length' => 50,
	]);

	/// Last Name
	createField('user', 'field_last_name', 'string', 'Last Name', false, '', [
		'max_length' => 50,
	]);

	/// Bio
	createField('user', 'field_bio', 'text_long', 'Biography', false, '', [
		'max_length' => 700,
	]);

	/// Phone Number
	createField(
		'user',
		'field_phone',
		'integer',
		'Phone Number',
		false,
		0,
		[
			'min' => 10000,
			'max' => 9999999999,
		],
		[
			'Regex' => [
				'pattern' => '/^\+?[0-9]{7,15}$/',
				'message' => 'Enter a valid phone number.',
			],
		],
	);

	/// Country
	createField(
		'user',
		'field_country',
		'string',
		'Country',
		false,
		'US',
		[
			'max_length' => 2,
		],
		[
			'Regex' => [
				'pattern' => '[A-Z]{2}',
				'message' => 'Enter a valid country code.',
			],
		],
	);

	/// Address
	createField('user', 'field_address', 'string', 'Address', false, '', [
		'max_length' => 255,
	]);

	/// Activities
	createField('user', 'field_activities', 'json', 'Activities', false, json_encode([]), [
		'schema' => [
			'$schema' => 'http://json-schema.org/draft-07/schema#',
			'type' => 'array',
			'items' => [
				'type' => 'string',
				'format' => 'number',
			],
		],
	]);

	/// Friends
	createField('user', 'field_friends', 'json', 'Friends', false, json_encode([]), [
		'schema' => [
			'$schema' => 'http://json-schema.org/draft-07/schema#',
			'type' => 'array',
			'items' => [
				'type' => 'string',
				'format' => 'number',
			],
		],
	]);

	/// Circle
	createField('user', 'field_circle', 'json', 'Circle', false, json_encode([]), [
		'schema' => [
			'$schema' => 'http://json-schema.org/draft-07/schema#',
			'type' => 'array',
			'items' => [
				'type' => 'string',
				'format' => 'number',
			],
		],
	]);

	/// Account Type
	createField('user', 'field_account_type', 'list_string', 'Account Type', true, 'FREE', [
		'allowed_values' => array_map(fn($case) => $case->value, AccountType::cases()),
	]);

	/// Email Verified
	createField('user', 'field_email_verified', 'boolean', 'Email Verified', false, false);

	/// OAuth Provider IDs
	createField('user', 'field_oauth_google_sub', 'string', 'Google OAuth Sub', false, '', [
		'max_length' => 255,
	]);

	createField('user', 'field_oauth_microsoft_sub', 'string', 'Microsoft OAuth Sub', false, '', [
		'max_length' => 255,
	]);

	createField('user', 'field_oauth_discord_sub', 'string', 'Discord OAuth Sub', false, '', [
		'max_length' => 255,
	]);

	createField('user', 'field_oauth_github_sub', 'string', 'GitHub OAuth Sub', false, '', [
		'max_length' => 255,
	]);

	createField('user', 'field_oauth_facebook_sub', 'string', 'Facebook OAuth Sub', false, '', [
		'max_length' => 255,
	]);

	/// Subscribed
	createField('user', 'field_subscribed', 'boolean', 'Subscribed', false, true);

	/// Notifications
	createField('user', 'field_notifications', 'json', 'Notifications', false, json_encode([]), [
		'schema' => [
			'$schema' => 'http://json-schema.org/draft-07/schema#',
			'type' => 'array',
			'items' => [
				'type' => 'object',
				'properties' => [
					'user_id' => ['type' => 'integer'],
					'message' => ['type' => 'string'],
					'timestamp' => ['type' => 'integer'],
					'link' => ['type' => ['string', 'null']],
					'type' => ['type' => 'string'],
					'source' => ['type' => 'string'],
					'read' => ['type' => 'boolean'],
				],
				'required' => ['user_id', 'message', 'type', 'source', 'read', 'timestamp'],
			],
		],
	]);

	/// Previous IPs
	createField('user', 'field_previous_ips', 'json', 'Previous IPs', false, json_encode([]), [
		'schema' => [
			'$schema' => 'http://json-schema.org/draft-07/schema#',
			'type' => 'array',
			'items' => [
				'type' => 'string',
				'format' => 'ipv4',
			],
		],
	]);

	// Make sure the user form display shows all custom fields on fresh install.
	mantle2_ensure_form_display('user', 'user');

	// Activities

	createContentType('activity', 'Activity', 'Activity content type', [
		[
			'name' => 'field_activity_id',
			'type' => 'string',
			'label' => 'Activity ID',
			'required' => true,
		],
		[
			'name' => 'field_activity_name',
			'type' => 'string',
			'label' => 'Activity Name',
			'required' => true,
		],
		[
			'name' => 'field_activity_description',
			'type' => 'text_long',
			'label' => 'Activity Description',
			'required' => true,
			'settings' => [
				'max_length' => 2048,
			],
		],
		[
			'name' => 'field_activity_types',
			'type' => 'list_string',
			'label' => 'Activity Types',
			'required' => true,
			'settings' => [
				'allowed_values' => Mantle2Schemas::activityTypes(),
			],
			'cardinality' => 5,
		],
		[
			'name' => 'field_activity_aliases',
			'type' => 'json',
			'label' => 'Activity Aliases',
			'required' => false,
			'settings' => [
				'schema' => [
					'$schema' => 'http://json-schema.org/draft-07/schema#',
					'type' => 'array',
					'items' => [
						'type' => 'string',
					],
				],
			],
		],
		[
			'name' => 'field_activity_fields',
			'type' => 'json',
			'label' => 'Activity Fields',
			'required' => false,
		],
	]);

	// Events

	// Migrate event activity types with backup safety
	$backup_id = mantle2_backup_event_activities();
	$migrated_data = mantle2_migrate_event_activities();

	if ($migrated_data === null && $backup_id !== null) {
		// Migration failed, attempt rollback
		Drupal::logger('mantle2')->error('Event activity migration failed, attempting rollback...');
		mantle2_rollback_event_activities($backup_id);
	}

	createContentType('event', 'Event', 'Event content type', [
		[
			'name' => 'field_host_id',
			'type' => 'integer',
			'label' => 'Host ID',
			'required' => true,
		],
		[
			'name' => 'field_event_name',
			'type' => 'string',
			'label' => 'Event Name',
			'required' => true,
			'settings' => [
				'max_length' => 255,
			],
		],
		[
			'name' => 'field_event_description',
			'type' => 'text_long',
			'label' => 'Event Description',
			'required' => true,
			'settings' => [
				'max_length' => 2048,
			],
		],
		[
			'name' => 'field_event_type',
			'type' => 'list_string',
			'label' => 'Event Type',
			'required' => true,
			'settings' => [
				'allowed_values' => array_map(fn($case) => $case->value, EventType::cases()),
			],
			'cardinality' => 1,
		],
		[
			'name' => 'field_event_activity_types',
			'type' => 'json',
			'label' => 'Activity Types',
			'required' => true,
			'default_value' => json_encode([]),
			'settings' => [
				'schema' => [
					'$schema' => 'http://json-schema.org/draft-07/schema#',
					'type' => 'array',
					'maxItems' => 20,
					'items' => [
						'oneOf' => [
							[
								'type' => 'object',
								'properties' => [
									'type' => ['const' => 'activity'],
									'id' => ['type' => 'string'],
									'name' => ['type' => 'string'],
									'description' => ['type' => ['string', 'null']],
									'types' => [
										'type' => 'array',
										'items' => ['type' => 'string'],
									],
									'aliases' => [
										'type' => 'array',
										'items' => ['type' => 'string'],
									],
									'fields' => ['type' => 'object'],
								],
								'required' => ['type', 'id', 'name'],
							],
							[
								'type' => 'object',
								'properties' => [
									'type' => ['const' => 'activity_type'],
									'value' => ['type' => 'string'],
								],
								'required' => ['type', 'value'],
							],
						],
					],
				],
			],
			'cardinality' => 1,
		],
		[
			'name' => 'field_event_location_latitude',
			'type' => 'float',
			'label' => 'Location Latitude',
			'required' => false,
			'settings' => [
				'min' => -90,
				'max' => 90,
			],
		],
		[
			'name' => 'field_event_location_longitude',
			'type' => 'float',
			'label' => 'Location Longitude',
			'required' => false,
			'settings' => [
				'min' => -180,
				'max' => 180,
			],
		],
		[
			'name' => 'field_event_date',
			'type' => 'datetime',
			'label' => 'Date',
			'required' => true,
		],
		[
			'name' => 'field_event_enddate',
			'type' => 'datetime',
			'label' => 'End Date',
			'required' => false,
		],
		[
			'name' => 'field_visibility',
			'type' => 'list_string',
			'label' => 'Visibility',
			'required' => true,
			'settings' => [
				'allowed_values' => array_map(fn($case) => $case->value, Visibility::cases()),
			],
			'cardinality' => 1,
		],
		[
			'name' => 'field_event_attendees',
			'type' => 'entity_reference',
			'label' => 'Event Attendees',
			'required' => false,
			'settings' => [
				'target_type' => 'user',
			],
			'cardinality' => -1,
		],
		[
			'name' => 'field_event_fields',
			'type' => 'json',
			'label' => 'Event Fields',
			'required' => false,
		],
	]);

	// Restore migrated activity data to events
	if ($migrated_data !== null && !empty($migrated_data)) {
		$restore_success = mantle2_restore_event_activities($migrated_data);

		if (!$restore_success && $backup_id !== null) {
			// Restore failed, attempt rollback
			Drupal::logger('mantle2')->error(
				'Event activity restoration failed, attempting rollback...',
			);
			mantle2_rollback_event_activities($backup_id);
		} else {
			// Clean up successful backup
			if ($backup_id !== null) {
				try {
					if (class_exists('\Drupal\mantle2\Service\RedisHelper')) {
						\Drupal\mantle2\Service\RedisHelper::delete($backup_id);
					}

					$connection = Drupal::database();
					if ($connection->schema()->tableExists('mantle2_migration_backup')) {
						$connection
							->delete('mantle2_migration_backup')
							->condition('backup_id', $backup_id)
							->execute();
					}
				} catch (Exception $e) {
					// Ignore cleanup errors
				}
			}
		}
	}

	// Prompts

	createContentType('prompt', 'Prompt', 'Prompt content type', [
		[
			'name' => 'field_prompt',
			'type' => 'text_long',
			'label' => 'Prompt',
			'required' => true,
			'settings' => [
				'max_length' => 100,
			],
		],
		[
			'name' => 'field_owner_id',
			'type' => 'integer',
			'label' => 'Owner ID',
			'required' => true,
			'settings' => [
				'min' => 1,
			],
		],
		[
			'name' => 'field_visibility',
			'type' => 'list_string',
			'label' => 'Visibility',
			'required' => true,
			'settings' => [
				'allowed_values' => array_map(fn($case) => $case->value, Visibility::cases()),
			],
			'cardinality' => 1,
		],
	]);

	// Articles (with corrected field types from update 9005)

	createContentType('article', 'Article', 'Article content type', [
		[
			'name' => 'field_article_title',
			'type' => 'string',
			'label' => 'Title',
			'required' => true,
			'settings' => [
				'max_length' => 255,
			],
		],
		[
			'name' => 'field_article_description',
			'type' => 'text_long',
			'label' => 'Description',
			'required' => true,
		],
		[
			'name' => 'field_article_tags',
			'type' => 'json',
			'label' => 'Tags',
			'required' => false,
			'settings' => [
				'schema' => [
					'$schema' => 'http://json-schema.org/draft-07/schema#',
					'type' => 'array',
					'items' => [
						'type' => 'string',
					],
				],
			],
		],
		[
			'name' => 'field_article_content',
			'type' => 'text_long',
			'label' => 'Content',
			'required' => true,
		],
		[
			'name' => 'field_author_id',
			'type' => 'entity_reference',
			'label' => 'Author ID',
			'required' => true,
			'settings' => [
				'target_type' => 'user',
			],
		],
		[
			'name' => 'field_article_color',
			'type' => 'integer',
			'label' => 'Color',
			'required' => false,
		],
		[
			'name' => 'field_ocean_article',
			'type' => 'json',
			'label' => 'Ocean Article',
			'required' => false,
			'settings' => [
				'schema' => [
					'$schema' => 'http://json-schema.org/draft-07/schema#',
					'type' => 'object',
					'properties' => [
						'title' => ['type' => 'string'],
						'author' => ['type' => 'string'],
						'source' => ['type' => 'string'],
						'url' => ['type' => 'string'],
						'abstract' => ['type' => 'string'],
						'content' => ['type' => 'string'],
						'theme_color' => ['type' => 'string'],
						'keywords' => [
							'type' => 'array',
							'items' => ['type' => 'string'],
						],
						'date' => ['type' => 'string'],
						'favicon' => ['type' => 'string'],
						'links' => [
							'type' => 'object',
							'additionalProperties' => ['type' => 'string'],
						],
					],
				],
			],
		],
	]);

	// Complete comment system setup (consolidated from updates 9004 and 9009)
	$module_handler = Drupal::moduleHandler();
	if (!$module_handler->moduleExists('comment')) {
		/** @var Drupal\Core\Extension\ModuleInstallerInterface $installer */
		$installer = Drupal::service('module_installer');
		try {
			$installer->install(['comment']);
		} catch (Exception $e) {
			Drupal::logger('mantle2')->error(
				'Failed to enable comment module during install: %message',
				['%message' => $e->getMessage()],
			);
		}
	}

	// Ensure base comment type exists.
	if (!CommentType::load('comment')) {
		try {
			CommentType::create([
				'id' => 'comment',
				'label' => 'Comment',
				'target_entity_type_id' => 'node',
			])->save();
		} catch (Exception $e) {
			Drupal::logger('mantle2')->error(
				'Failed to create Comment type during install: %message',
				['%message' => $e->getMessage()],
			);
		}
	}

	// Ensure comment_body field storage exists.
	if (!FieldStorageConfig::loadByName('comment', 'comment_body')) {
		try {
			FieldStorageConfig::create([
				'field_name' => 'comment_body',
				'entity_type' => 'comment',
				'type' => 'text_long',
				'cardinality' => 1,
				'translatable' => true,
			])->save();
		} catch (Exception $e) {
			Drupal::logger('mantle2')->error(
				'Failed to create comment_body field storage during install: %message',
				['%message' => $e->getMessage()],
			);
		}
	}

	// Ensure comment_body field instance exists.
	if (!FieldConfig::loadByName('comment', 'comment', 'comment_body')) {
		try {
			FieldConfig::create([
				'field_name' => 'comment_body',
				'entity_type' => 'comment',
				'bundle' => 'comment',
				'label' => 'Comment',
				'required' => true,
			])->save();
		} catch (Exception $e) {
			Drupal::logger('mantle2')->error(
				'Failed to create comment_body field instance during install: %message',
				['%message' => $e->getMessage()],
			);
		}
	}

	// Ensure comment_body appears in form and view displays.
	try {
		$form_display = EntityFormDisplay::load('comment.comment.default');
		if ($form_display && !$form_display->getComponent('comment_body')) {
			$form_display
				->setComponent('comment_body', [
					'type' => 'text_textarea',
					'settings' => ['rows' => 5],
				])
				->save();
		}

		$view_display = EntityViewDisplay::load('comment.comment.default');
		if ($view_display && !$view_display->getComponent('comment_body')) {
			$view_display
				->setComponent('comment_body', [
					'label' => 'hidden',
					'type' => 'text_default',
				])
				->save();
		}
	} catch (Exception $e) {
		Drupal::logger('mantle2')->warning('Failed to configure comment_body displays: %message', [
			'%message' => $e->getMessage(),
		]);
	}

	// Ensure comment field storage exists for nodes.
	$storage = FieldStorageConfig::loadByName('node', 'comment');
	if (!$storage) {
		try {
			FieldStorageConfig::create([
				'field_name' => 'comment',
				'entity_type' => 'node',
				'type' => 'comment',
				'cardinality' => -1,
			])->save();
		} catch (Exception $e) {
			Drupal::logger('mantle2')->error(
				'Failed to create comment field storage during install: %message',
				['%message' => $e->getMessage()],
			);
		}
	} elseif ($storage->getCardinality() !== -1) {
		try {
			$storage->setCardinality(-1)->save();
		} catch (Exception $e) {
			Drupal::logger('mantle2')->warning(
				'Failed to adjust comment field storage cardinality: %message',
				['%message' => $e->getMessage()],
			);
		}
	}

	// Clean up bad 'node' bundle instance if it exists.
	if ($bad = FieldConfig::loadByName('node', 'node', 'comment')) {
		try {
			$bad->delete();
		} catch (Exception $e) {
			// Ignore.
		}
	}

	// Ensure the comment field instance exists for the prompt bundle.
	$instance = FieldConfig::loadByName('node', 'prompt', 'comment');
	if (!$instance) {
		try {
			FieldConfig::create([
				'field_name' => 'comment',
				'entity_type' => 'node',
				'bundle' => 'prompt',
				'label' => 'Comments',
				'required' => false,
				'settings' => ['comment_type' => 'comment'],
			])->save();
		} catch (Exception $e) {
			Drupal::logger('mantle2')->error(
				'Failed to attach comment field to prompt during install: %message',
				['%message' => $e->getMessage()],
			);
		}
	} else {
		try {
			$settings = $instance->getSettings();
			$settings['comment_type'] = 'comment';
			$instance->set('settings', $settings)->save();
		} catch (Exception $e) {
			Drupal::logger('mantle2')->warning(
				'Failed to update comment_type setting on prompt comment field: %message',
				['%message' => $e->getMessage()],
			);
		}
	}

	foreach (['activity', 'event', 'prompt', 'article'] as $bundle) {
		mantle2_ensure_form_display('node', $bundle);
	}

	mantle2_ensure_form_display('user', 'user');
	mantle2_ensure_form_display('comment', 'comment');
}
